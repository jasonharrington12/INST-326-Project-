# -*- coding: utf-8 -*-
"""Project2ClassesSteven.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1muPVQZLxpdtgOwWIv00L3NL_VqvY5veX
"""

class LibraryStats:
    """
    A class to manage and analyze a personal library of books, movies, and user activity.

    Attributes are private and can only be accessed via properties.

    Example:
    --------
    >>> library = [{"title": "Book A", "rating": 5}, {"title": "Book B", "rating": None}]
    >>> movies = [{"title": "Movie A", "rating": 4}]
    >>> users = [{"name": "Alice", "books_read": 3, "movies_watched": 2}]
    >>> stats = LibraryStats(library, movies, users)
    >>> print(stats)
    LibraryStats with 2 books, 1 movies, and 1 users.
    """

    def __init__(self, library=None, movies=None, users=None):
        # Validate types
        if library is not None and not isinstance(library, list):
            raise TypeError("library must be a list of dictionaries")
        if movies is not None and not isinstance(movies, list):
            raise TypeError("movies must be a list of dictionaries")
        if users is not None and not isinstance(users, list):
            raise TypeError("users must be a list of dictionaries")

        self._library = library if library is not None else []
        self._movies = movies if movies is not None else []
        self._users = users if users is not None else []

    # ========== Properties for Encapsulation ==========
    @property
    def library(self):
        return self._library

    @library.setter
    def library(self, value):
        if not isinstance(value, list):
            raise TypeError("library must be a list")
        self._library = value

    @property
    def movies(self):
        return self._movies

    @movies.setter
    def movies(self, value):
        if not isinstance(value, list):
            raise TypeError("movies must be a list")
        self._movies = value

    @property
    def users(self):
        return self._users

    @users.setter
    def users(self, value):
        if not isinstance(value, list):
            raise TypeError("users must be a list")
        self._users = value

    def get_highest_rated_books(self):
        """Return list of highest-rated book titles (rating must not be None)."""
        rated = [b for b in self._library if b.get("rating") is not None]
        if not rated:
            return []
        max_rating = max(b["rating"] for b in rated)
        return [b["title"] for b in rated if b["rating"] == max_rating]

    def get_unrated_books(self):
        """Return list of books without ratings."""
        return [b["title"] for b in self._library if b.get("rating") is None]

    def get_highest_rated_movies(self):
        """Return highest-rated movie titles."""
        rated = [m for m in self._movies if m.get("rating") is not None]
        if not rated:
            return []
        max_rating = max(m["rating"] for m in rated)
        return [m["title"] for m in rated if m["rating"] == max_rating]

    def get_unrated_movies(self):
        """Return movies without ratings."""
        return [m["title"] for m in self._movies if m.get("rating") is None]

    def get_top_users(self):
        """
        Return users with the highest total number of books read + movies watched.
        Returns a list of (name, total_items) tuples.
        """
        stats = []
        for u in self._users:
            total = u.get("books_read", 0) + u.get("movies_watched", 0)
            stats.append((u.get("name", "Unknown"), total))

        if not stats:
            return []

        max_total = max(total for _, total in stats)
        return [(name, total) for name, total in stats if total == max_total]


    def __str__(self):
        return f"LibraryStats with {len(self._library)} books, {len(self._movies)} movies, and {len(self._users)} users."

    def __repr__(self):
        return f"LibraryStats(library={len(self._library)}, movies={len(self._movies)}, users={len(self._users)})"